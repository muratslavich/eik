# c++ algs

**typedef - новое имя для существующего типа**

**Главная функция ссылается на определяемый тип данных,**

**а не встроенный тип. Не указывая тип мы расширяем область применения программы.**

**Например�**�**typedef int Number; и Number randNum(){} можно вынести в другой файл(или в заголовочный) и подключить include.**

**Или создать несколько Number.h для различных типов и менять их в главной программе.**

**Независимо от типа данны�**�

\*\*    индексы - int\*\*

\*\*    среднее - float\*\*

Вообще программа зависит от возможности преобразования Number во float, его можно описать явно для любого типа number

/\*\*

\*Пример вычисляет среднее значение и среднеквадратичное отклонение  последовательности целых чисел,

\*сгенерированных билиотечной rand();

\*/

\#include \<iostream.h>

\#include \<stdlib.h>

\#include \<math.h>

typedef int Number; //определение синонима int

Number randNum()&#x20;

{

&#x20;   return rand();

}

int main(int argc, char \*argv\[])&#x20;

{

&#x20;   int N = atoi(argv\[1]);

&#x20;   float ml = 0.0, m2 = 0.0;

&#x20;   for (int i = 0; i < N; i++)&#x20;

&#x20;   {

&#x20;       Number x = randNum();

&#x20;       ml += ((float) x)/N;

&#x20;       m2 += ((float) x\*x)/N;

&#x20;   }

&#x20;   cout << " Среднее: " << ml << endl;

&#x20;   cout << "Ср.-кв.откл.: " << sqrt(m2-m1\*m1) << endl;

}

**Правильно разбивать код на 3 файла:**

\*\*    интерфейс - определяется структура данных и объявляются функции, используемые для упраления этой структурой\*\*

\*\*    реализация - функции объявленные в интерфейсе\*\*

\*\*    Клиентская программа - использующая функции из интерфейса для работы на более высоком уровне абстракции\*\*

**// интерфейс Number.h**

**typedef int Number;**

**Number randNum();**

// Реализация Number.cpp

\#include \<stdlib.h>

\#include "Number.h"

Number randNum()

{

&#x20;   return rand();

}

// клиентская программа

\#include \<iostream.h>

\#include \<math.h>

\#include "Number.h"

int main(int argc, char \*argv\[])

{

&#x20;   int N = atoi(argv\[1]);

&#x20;   float ml = 0.0, m2 = 0.0;

&#x20;   for (int i = 0; i < N; i++)&#x20;

&#x20;   {

&#x20;       Number x = randNum();

&#x20;       ml += ((float) x)/N;

&#x20;       m2 += ((float) x\*x)/N;

&#x20;   }

&#x20;   cout << " Среднее: " << ml << endl;

&#x20;   cout << "Ср.-кв.откл.: " << sqrt(m2-m1\*m1) << endl;

}

**Таким образом код связанный с типом данных инкапсулирован и может использоваться другими клиентскими программами, а клиент без изменений может использовать другие типы данных.**

**Структуры**

**Сгруппированные типы, используемые для описания наборов данных. Это позволяет управлять набором как единым целым, но с возможностью ссылаться на отдельные компоненты по именам.**

**Используются для описания новых типов данных, а так же для определения операций с этипи типами.�**�

/\*\*

\*интерфейс Point.h

\*пример абстракция точки на плоскости

\*/

struct point { float x; float y };

float distance(point, point);

&#x20;

struct point a, b; //объявление двух переменных этого типа

//можно ссылаться по имени на отдельные члены структуры

a.x = 1.0;

a.y = 1.0;

//структуру можно передавать функциям в качестве аргументов

/\*\*

\*реализация структуры point

\*/

\#include \<math.h>

\#include "Point.h"

float distance(point a, point b)

{

&#x20;   float dx = a.x - b.x, dy = a.y - b.y;

&#x20;   return sqrt(dx\*dx + dy\*dy);

}

**Массивы**

static const int N = 1000;

int main()

{&#x20;

&#x20;   int a\[N];     //статическое выделение памяти массиву

}

int N = atoi(argv\[1]);

int \*a = new int\[N];     // динамическое выделение памяти массиву, возвращает указатель на массив

***

int main(int argc, char \*argv\[])

{&#x20;

&#x20;   int i, N = atoi(argv\[1]);

&#x20;   int \*a = new int\[N];

&#x20;   if (a == 0)

&#x20;       { cout << "не хватает памяти" << endl; return 0; }

}

Vector - класс из стандартной библиотеке который можно индексировать как массив с необязательной проверкой соответствия диапазону(автоматически проверяется компилятором). Он также способен к расширению и усечению

**Связный список**

```
//абстракция связного списка
struct node
{
     Item item;
     node *next;
     //конструктор
     node (Item x; node *t)
          { item = x; next = t; }
};
typedef node *link

//создание узла списка
link t = new node(x, t);

//осуществление ссылок на элемент и ссылку
x->item
x->link

//2 основные операции для связных списков - вставить и удалить
//удаление узла, следующего после узла x
t = x->next;
x->next = t->next;
delete t;
или
x->next = x->next;
x->next = t;

//вставка узла t, в позицию след за узлом x
t->next = x->next;
x->next = t;

//обход списка, где x - указатель на первый узел списка,
//последний узел имеет null-указатель
//visit - процедура, которая принимает элемнет в качестве аргумента
for (link t = x; t !=  0;  t = t->next)  visit(t->item)

//обращение порядка следования элементов списка
link reverse(link x)
{
     link t, y = x, r = 0;
     while (y != 0)
     {
          t = y->next;
          y->next = r;
          r = y;
          y = t;
     }
     return r;
}
```

Таблица 3.1. Соглашения о первом и последнем узлах в связных списках

**Циклический список, всегда непустой**

первая вставка:head->next = head;

вставка t после х:t->next = x->next; x->next = t;

удаление после х:x->next = x->next->next;

цикл обхода:t = head;do { ... t = t->next; } while (t != head);

проверка на наличие лишь одного элемента:if (head->next == head)

**Указатель на начало, пустой указатель в конце**

инициализация:head = 0;

вставка t после х:if (x == 0) {head = t; head->next = 0; }

&#x20;              else { t->next = x->next; x->next = t; }

удаление после х:t = x->next; x->next = t->next;

цикл обхода:for (t = head; t != 0; t = t->next)

проверка на пустоту:if (head == 0)

**Фиктивный ведущий узел, пустой указатель в конце**

инициализация:head = new node; head->next = 0;

вставка t после х:t->next = x->next; x->next = t;

удаление после х:t = x->next; x->next = t->next;

цикл обхода:for (t = head->next; t != 0; t = t->next)

проверка на пустоту:if (head->next == 0)

**Фиктивные ведущий и завершающий узлы**

инициализация:     head = new node;

&#x20;              z = new node;

&#x20;              head->next = z; z->next = z;

вставка t после х:t->next = x->next; x->next = t;

удаление после х:x->next = x->next->next;

цикл обхода:for (t = head->next; t != z; t = t->next)

проверка на пустоту:if (head->next == z)

_Программа 3.11. Сортировка методом вставки в список_

Этот код генерирует N случайных целых чисел в диапазоне от 0 до 999, строит связный список, в котором на каждый узел приходится по одному числу (первый цикл for), затем переупорядочивает узлы, чтобы при обходе списка числа следовали по возрастанию (второй цикл for). Для выполнения сортировки используется два списка - входной (несортированный) и выходной (сортированный). В каждой итерации цикла из входного списка удаляется узел и вставляется в нужную позицию выходного списка. Код упрощен благодаря использованию в каждом списке ведущих узлов, содержащих ссылки на первые узлы. В объявлениях ведущих узлов применен конструктор, поэтому их данные инициализируются при создании.

node heada(0, 0); link a = \&heada, t = a;

for (int i = 0; i < N; i++)

t = (t->next = new node(rand() % 1000, 0));

node headb(0, 0); link u, x, b = \&headb;

for (t = a->next; t != 0; t = u)

{ u = t->next;

for (x = b; x->next != 0; x = x->next)

if (x->next->item > t->item) break;

t->next = x->next; x->next = t;

}

**Рис. 3.8.**  Сортировка связного списка

На этой диаграмме показан один шаг преобразования неупорядоченного связного списка (заданного указателем a) в упорядоченный связный список (заданный указателем b) с использованием сортировки вставками. Сначала берется первый узел неупорядоченного списка, и указатель на него сохраняется в t (вверху). Затем выполняется поиск в b первого узла x, для которого справедливо условие x->next->item > t->item (или x->next = NULL), и t вставляется в список после x (в середине). Эти операции уменьшают на один узел размер списка a и увеличивают на один узел размер списка b, сохраняя список b упорядоченным (внизу). После завершения цикла список a окажется пустым, а список b будет содержать все узлы в упорядоченном виде.

**Особенность двухсвязных списков - удаление узла, когда ссылка на узел является единственной информацией о нем.**

**Связные списки эффективно изменяют размеры на протяжении жизни. Необязательно заранее знать максимальный размер списка.**

**Распределение памяти**

* **стандартными средствами new delete**
* **прямое ручное распределение памяти с помощью свободного списка freelist**

Строки

Абстрактное понятие последовательности символов, завершаемых символом конца строки, может быть реализовано разными способами.

* Связными списками,
* массивом,
* обобщенная реализация из стандартной библиотеке

Элементарные операции со строками

* вычисление длины строки strlen(a)

for (i  = 0; a\[i] != 0; i++); return i;

* копирование strcpy(a, b)

for (i = 0; a\[i] == b\[i] != 0; i++&#x20;

* сравнение strcmp(a, b)
* сравнение префикс strncmp(a, b, n)
* присоединение strcat(a, b)
