# Garbage Collector





## Garbage Collector и работа с памятью

Garbage collector (GC)

\* поиск недостежимых объектов&#x20;

\* освобождение памяти

&#x20;    разные алгоритмы освобождения

\* вызов finalize&#x20;

&#x20;    будет вызван у каждого удаляющегося объекта, его лучше не использовать явно и она не гарантирует удаление

**Типы ссылок**

\* Strong references. Сильнодостижимые объекты (используется при удалении).

\* Weak references. Возможность заполнить ссылку на объект, но не участвует при подсчете количества ссылок перед удалением. Не дают нам гарантии, что объект существует.&#x20;

\* Soft references. Основа построения кешей. Soft references держит ссылку на объект до тех пор пока достаточно памяти.

\* Phantom references. Нужны если мы хотим получить уведомление о том, что произошло удаление объекта.

***

\>Stack (корневое множество) -----> Heap (живые объекты. сильнодостижимые) + (недостижимые объекты. мусор)&#x20;

Для того, что бы понять можно удалять объект или нет, составляется граф достижимости и если на объект есть путь по ссылкам из стека, то он не удаляется.&#x20;

Сборщик мусора работает в нескольких режимах в зависимости от того сколько памяти осталось. Если памяти много, то будет происходить сборка молодого поколения, если меньше, то будут освобождаться объекты которые прошли до этого сборку и если совсем мало, то запуститься fool gc (поиск и удаление всех объектов, которые можно удалить).&#x20;

\#### Garbage Collector (Java 7)

HotSpot JVM память можно было разбить на 3 части:

\* память под Stack (на каждый поток по стеку)

\* память под Heap (то место где лежать основные объекты)

\* Permanent generation (место, где лежит информация о классах и JVM)

Heap делится на:&#x20;

\* New generation (появляются новые объекты)

\* Old generation (лежат те объекты, которые пережили множественное количество сборок)&#x20;

\*Процесс создания нового объекта в New generation\*

Когда мы создаем новый объект, то мы создаем его в области памяти под названием Eden. Если этот объект с коротким периодом жизни (создали, поработали и потеряли ссылку на него), то в Edene сборака таких объектов происходит очень дешево. Минорные сборки, которые по чуть-чуть подчищают мусор. Если при проверке объектов (необходимо очистить память), объект в Eden-е содержит на себя входящую ссылку (живой объект), то его из Eden-а перемещают в Survivor. Если при последующей проверке объект опять оказывается достижимым (уже в Survivor), то его переносят во-второй Survivor. Если объект снова пережил сборку мусора (на него есть ссылка), то его переносят в Old Generation. Чем дальше объект от Eden-а, тем реже к нему будут обращаться для проверки удалять его или нет. Сложнее всего чистить old generation, т.к. он чиститься, когда мы проходим full gc.&#x20;

Есть некоторые параметры, которые отвечают за то как должен работать сборщик мусора и сколько памяти должно быть выделено на приложение для работы в JVM (параметры запуска JVM):

\* -XX:PermSize и -XX:MaxPermSize - когда мы выделяем область памяти под Perm Generation

\* -Xmx и Xms - таким образом мы можем задать размер Heap-а

\* -XX:NewSize и -XX:MaxNewSize - указываем количество памяти под New generation.

В Java 8 - отказались от Permanen generation и заменили на MaxMetaspaceSize - область в Heap-е, в которую мы складываем все то, что раньше лежало в permanent generation.

***
